## A*寻路算法

let startli=1;

let endli=2;

let totalLi=20;

//f(n) return num n点和目标点之间的距离 
//g(n) return 起始点到n点的距离
//h(n) return n点和最终点的距离

//提供两个队列，一个closeArr,一个openArr
//closeArr存放已经走过的点和障碍物
//openArr存放将要走的点

//对openArr中的每个点进行距离评估排序，把距离最终点最近的排到最前面。
//然后再次寻路，在把上一次找到的最近点存储到closeArr中，直到，找到的点与最终点相同，停止寻路


## 八皇后算法

- 规则，每个皇后只能放在一行上面，换言之，一行只能出现一个皇后。

- 主要实现算法：利用递归和回溯

- 要点：
第一步：在棋盘中放入第一个皇后，然后把该皇后所在行，所在列还有皇后的左斜方，右斜方都封禁。
第二步：在剩下的格子中放入第二个皇后，第二个皇后必须放在第一个皇后的下一行中，放入之后再此执行第一步中的判断方法。如果发现无法放入皇后的话我们就需要回溯到最开始的运算，从新放入第一个皇后，直到棋盘中皇后的数量达到跟棋盘行数一样为止。


## 螺旋矩阵

- 构成如下矩阵
  
![Alt text](./螺旋矩阵.png)

- 找到拐点。
- 缩小环数。
- 给数组中的每个元素定义一个坐标，再定义两个值一个作为整个数组的最大列数，一个作为整个数组的最小行数。
- 然后遍历数组，并判断：
- 第一拐点：当前列是否小于最大列，并且当前行是否等于最小行。如果满足条件，则行不变，列加1。
- 第二拐点：当前行是否小于最大行，并且当前列是否等于最大列。满足条件，则列不变，行加1。
- 第三拐点：当前行是否等于最大行，当前列是否大于最小列。满足条件，则行不变，列减1。
- 第四拐点：当前列是否等于最大列，当前行是否大于最小行。满足条件，则列不变，行减1。
- 一轮过去后，环数减1，也就是说，最小行加1，最大列减1。

## 